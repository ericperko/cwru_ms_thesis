\section{Trajectory Generation}\label{sec:trajectory_generation}\todo{Wyatt, any references for trajectory generation stuff that would be useful for this section?}

Another major compenent of the path execution subsystem developed in this thesis is trajectory generation. This componenet sits between the steering and path planning components, taking global paths from path planning and outputting desired states that the steering component attempts to achieve. The trajectory generator fills the same role as the ``base\_local\_planner'' described in \autoref{subsec:base_local_planner}. The input to the trajectory generator is an ordered sequence of path segments (called a \emph{path}). The path segments are described in \autoref{subsec:path_segment}. The output is a desired state for the current timestep, as described in \autoref{subsec:steering_state}.

\subsection{Path Segment Description}\label{subsec:path_segment}

The path segment used by the trajectory generator developed for this thesis is described in \autoref{table:path_segment_description}. There are three different types of path segments used in this thesis -- straight lines, smooth constant curvature arcs and spin-in-places. One important assumption about these path segments is that, for a given sequence of segments, they will already be bleneded together to remove any discontinuities in the geometric parameterization between the end of a segment and the beginning of the following segment.

\begin{table}[htbp]
	\begin{tabularx}{\textwidth}{|r|X|}
		\hline
		Name & Description \\
		\hline
		header & This is a standard ROS header type that contains information such as the reference frame the rest of the fields are in and the timestamp for when the path segment was generated \\
		\hline
		segment\_type & An integer enum representing the type this segment, such as a straight line segment, constant curvature arc segment or spin-in-place segment. \\
		\hline
		segment\_number & The ID number of the segment that generated this state. \\
		\hline
		segment\_length & The length of the segment. Whether it is in meters or radians depends on the \emph{segment\_type} \\
		\hline
		reference\_point & The reference point for this path segment. Interpretation depends on the \emph{segment\_type} \\
		\hline
		initial\_tangent\_angle & The intial tangent angle for this segment. Interpretation depends on the \emph{segment\_type} \\
		\hline
		curvature & The curvature of this segment. Exact interpretation depends on the \emph{segment\_type}. For straight lines curvature should be 0.0 \\
		\hline
		max\_speed & A pair of the maximum translational speed and maximum rotational speed to be used for this segment \\
		\hline
		min\_speed & A pair of the minimum translational speed and minimum rotational speed to be used for this segment \\	
		\hline
		acceleration\_limit & The acceleration limit for this segment. Whether it is in $m/s^2$ or $rads/s^2$ depends on the \emph{segment\_type} \\
		\hline
		deceleration\_limit	& The deceleration limit for this segment. Whether it is in $m/s^2$ or $rads/s^2$ depends on the \emph{segment\_type} \\
		\hline
	\end{tabularx}
	\caption{Path Segment State Field Description \label{table:path_segment_description}}
\end{table}

Of the fields listed in \autoref{table:path_segment_description}, the ones requiring the most explanation are the \emph{reference\_point} and the \emph{initial\_tangent\_angle}. The \emph{reference\_point} can have the following meanings, depending on \emph{segment\_type}. For a straight line segment, the reference point is the start point of the line segment. For a constant curvature arc, the reference point is the center of the circle that the arc belongs to (the radius of that circle is $1/curvature$). For a spin-in-place segment, the reference point is the point about which to spin. The \emph{initial\_tangent\_angle} can have the following means, depending on \emph{segment\_type}. For a straight line segment, the initial tangent angle is the direction of the line segment. For a constant curvature arc, the initial tangent angle defines the actual point along the circle where the the arc segment begins. For a spin-in-place segment, the initial tangent angle is angle that the spin should start from.

As discussed in \autoref{subsec:steering_state}, the spin-in-place segment type was added to the original path segment types to avoid numerical instability issues when using arcs with very small radii.

\subsection{Trajectory Generation Algorithm}\label{subsec:trajectory_generation_algorithm}

The trajectory generation algorithm used in this thesis is detailed in this section. On HARLIE, this loop ran at 20 Hz to regularly send commands to the steering algorithms detailed in \autoref{subsec:steering_algorithms}. Note that the trajectory generator and steering algorithm, while both run at 20 Hz, they are not explicitly synchronized.
\todo{Better access to the struct things when they are like $state_t.velocity$}
\todo{Use $\leftarrow$ or = for assignment of variables in algorithms?}

\begin{algorithm}
\caption{Trajectory Generation Algorithm}
\label{alg:trajectory_generation_algorithm}
\DontPrintSemicolon
\SetKwFunction{MakeHaltState}{MakeHaltState}
\SetKwFunction{GetCurrentRobotState}{GetCurrentRobotState}
\SetKwFunction{UpdateSegmentNumberAndDistance}{UpdateSegNumAndDist}
\SetKwFunction{ComputeVelocityCommand}{ComputeVelocityCommand}
\SetKwFunction{ComputeDesiredPose}{ComputeDesiredPose}

\KwIn{$state_{t-1}$, $path$, $i_{t-1}$, $l_{t-1}$}
\KwOut{$state_t$, $i_t$, $l_t$}

$robot\_state_t$ = \GetCurrentRobotState{} \;
\eIf{path $\neq \emptyset$}
{
	\tcp{Compute new desired state}
	$i_t$, $l_t$ = \UpdateSegmentNumberAndDistance{$robot\_state_t$, $path$, $i_{t-1}$, $l_{t-1}$, $state_{t-1}$} \;
	$v_t$ = \ComputeVelocityCommand{$path$, $i_t$, $l_t$} \;
	$pose_t$ = \ComputeDesiredPose{$path$, $i_t$, $l_t$} \;
	$state_t.segment\_type$ = $path\left[i_t\right].segment\_type$ \;
	$state_t.pose$ = $pose_t$ \;
	$state_t.rho$ = $path\left[i_t\right].curvature$ \;
	$state_t.velocity$ = $v_t$ \;
	\;
	\tcp{Check new desired state for collisions}
	\If{$state_t$ will be in collision}
	{
		$state_t$ = \MakeHaltState{$robot\_state_t$} \;
	}
}
{
	$i_t$ = $0$ \;
	$l_t$ = $0.0$ \;
	$state_t$ = \MakeHaltState{$robot\_state_t$} \;
}
\end{algorithm}

\autoref{alg:trajectory_generation_algorithm} describes the trajectory generation algorithm that runs at the loop rate of 20 Hz. Its inputs are the last desired state ($state_{t-1}$), the current path from the path planner ($path$), the last segment number being executed ($i_{t-1}$) and the distance traveled along that segment already ($l_{t-1}$). The outputs (which are fed into the the algorithm on the next loop as well as being sent to the steering algorithm) are the current desired state ($state_t$), the current segment number being executed ($i_t$) and the distance traveled along that segment after this loop ends ($l_t$). Note that the segment number being executed, $i_t$, is an index into the sequence of path segments contained in the $path$. Also note that all of the algorithms described here assume that positions and orientations have all been placed in the same reference frame; on HARLIE, this was done with the ROS ``tf'' library (see \todo{add ref to ros tf library}).

There are a number of algorithms used in \autoref{alg:trajectory_generation_algorithm}. Two of these are fairly simple: \GetCurrentRobotState and \MakeHaltState. \GetCurrentRobotState gets the current robot position, orientation and velocities in a robot specific manner. For HARLIE, this information came from the output of the localization subsystem described in \autoref{sec:localization}. \MakeHaltState takes the give state (usually the current robot state) and generates a state that would cause the steering algorithms to stop and maintain that state. In this case, it simply generates a spin-in-place state at the robot's current position and orientation with zero speeds and curvatures; effectively, this state causes steering to stop both translational and rotational motion until given a new commanded state.

\SetKwFunction{Length}{Length}

The other three algorithms used in \autoref{alg:trajectory_generation_algorithm} are more complicated and require more detailed explanation. In all of these algortihms, \Length is a simple function that returns the number of path segments in the $path$ it is given. These algorithms are based on zero-indexed sequences (such as arrays in C) as opposed to one-indexed containers such as those found in Matlab.

\begin{algorithm}
\caption{Update Segment Number and Distance Algorithm}
\label{alg:update_seg_num_and_dist_algorithm}
\DontPrintSemicolon

\KwIn{$robot\_state_t$, $path$, $i_{t-1}$, $l_{t-1}$, $state_{t-1}$}
\KwOut{$i_t$, $l_t$}

\If{$i_{t-1} \geq \Length{path}$}
{
	$i_t$ = $\Length{path}-1$ \;
	$end$ = true \;
}

$\delta l$ = $state_{t-1}.velocity \cdot dt$ \;

\eIf{$path\left[i_t\right]$ is a spin-in-place segment}
{
	$l_t$ = $l_{t-1} + \delta l$ \;	
}
{
	$l_t$ = $l_{t-1} + \delta l \cdot \cos\left(state_{t-1}.orientation - robot\_state_t.orientation\right) $ \; \nllabel{update_seg_num_project_onto_des_tangent_vec}
}

$\hat l$ = $path\left[i_t\right].segment\_length$ \;
\If{$l_t > \hat l$}
{
	$l_t$ = $0.0$ \;
	$i_t$ = $i_t + 1$ \;
}

\If{$i_t \geq \Length{path}$}
{
	$i_t$ = $\Length{path}-1$ \;
	$end$ = true \;
}

$\hat l$ = $path\left[i_t\right].segment\_length$ \; \nllabel{update_seg_num_seg_num_may_have_changed}

\If{$end$ is true}
{
	$l_t$ = $\hat l$ \;
}

\end{algorithm}

\autoref{alg:update_seg_num_and_dist_algorithm} is the \UpdateSegmentNumberAndDistance function used in \autoref{alg:trajectory_generation_algorithm}. Its inputs are the current robot state ($robot\_state_t$), the current path ($path$), the last segment number being executed ($i_{t-1}$), the distance traveled along that segment already ($l_{t-1}$) and the last desired state ($state_{t-1}$). \autoref{alg:update_seg_num_and_dist_algorithm} then updates the distance traveled along the current segment according to the velocity in $state_{t-1}$ while moving to the next segment when appropriate and not running past the end of the $path$. It then outputs these new values for the segment number being executed ($i_t$) and distance already traveled along that segment ($l_t$) for consumption by the remainder of \autoref{alg:trajectory_generation_algorithm}.

Two important details of this computation are on \autoref{update_seg_num_project_onto_des_tangent_vec} and \autoref{update_seg_num_seg_num_may_have_changed} of \autoref{alg:update_seg_num_and_dist_algorithm}. \autoref{update_seg_num_project_onto_des_tangent_vec} projects the robot's motion onto the the tangent vector of the last state. This prevents situations where the robot is moving nearly orthogonal to the desired state's tangent vector from advancing the distance traveled along the path segment too far for the actual distance along the path segment traveled. These situations can occur while using \emph{phase space steering} if there is a large lateral offset from the path -- \emph{phase space steering} is designed to move nearly orthogonal to the desired state's tangent vector in that situation. \autoref{update_seg_num_seg_num_may_have_changed} is required to ensure that the correct segment current segment and segment length is selected, even after all of the adjustments to the current segment number ($i_t$) have been made.


\todo{ComputeVelocityCommand algorithm/description}
\todo{ComputeDesiredPose algorithm/description}

\subsection{Adding Feedback for Planning}\label{subsec:trajectory_generation_actionlib}

\subsection{Collision Detection}\label{subsec:trajectory_generation_costmap3d}

\begin{comment}

\begin{enumerate}
\item talk about where the Lfollow feedback was used and how it impacted the performance
\item the math!
\item talk about improved interface thanks to actionlib and why that is important
\item octocostmap/costmap3d

\end{enumerate}

\end{comment}
