\section{Steering}\label{sec:steering}

Another major component of a navigation subsystem is the path execution componenet. There are a number of parts that make up a path execution component; in this thesis, there are three such compenents: steering, trajectory generation and path planning. The lowest-level component is steering. Steering's task is to take a desired robot state (this represents the ideal state of the robot at a given time) and the current robot state and, from those two inputs, produce a set of commands that will make the robot's current state converge on the desired state. The state of the robot is not simple a position and orientation, but also includes parameters such as translational and angular velocities and curvature.

\subsection{State Description}\label{subsec:steering_state}

In the precision steering algorithms developed for this thesis, the final version of the state description was made up of the fields described in \autoref{table:desired_state_description}.

\begin{table}[htbp]
	\begin{tabularx}{\textwidth}{|r|X|}
		\hline
		Name & Description \\
		\hline
		header & This is a standard ROS header type that contains information such as the state's timestamp as well as what reference frame the desired pose is in. \\
		\hline
		segment\_type & An integer enum representing the type of segment that generated this desired state, such as a straight line segment, constant curvature arc segment or spin-in-place segment. \\
		\hline
		segment\_number & The ID number of the segment that generated this state. \\
		\hline
		pose & A six degree of freedom pose, containing x, y and z coordinates as well as roll, pitch and yaw angles. \\
		\hline
		speed & The desired speed for this state. Whether the speed is in meters per second or radians per second depends on the \emph{segment\_type}. \\
		\hline
		rho & The desired curvature for this state. Not used for spin-in-place segments. \\
		\hline
		segment\_distance & How far along the path segment this state corresponds to. \\
		\hline
	\end{tabularx}
	\caption{Steering Desired State Field Description \label{table:desired_state_description}}
\end{table}

Of the fields listed in \autoref{table:desired_state_description}, most of the fields listed are obvious choices for inclusion in the state. For example, if part of the steering algorithm's task is to move the robot to a certain position and orientation in the environment, then obviously the steering algorithm needs that pose in order to move the robot to it. Other fields in this parameterization of the desired state are mainly for informational purposes or consistency with the structures used by the trajectory generator, such as the segment number or segment distance, and were not used by the steering algorithms themselves. One important choice is the parameterization of the segment type field used in this final version.

Originally, only two segment types were used: line segments and constant curvature arc segments. For the steering algorithms, there was no difference in interpretation of those two segment types. While these worked well for most path segments, representation of spin-in-place segments was somewhat hacky, simplying representing them as arcs with very small radii (e.g. less than 1 $\mu m$). Such a representation was acceptable at a theoretical level, as arcs with very small radii are reasonable approximations of a spin-in-place, but led to numerical stability issues when using such small numbers in the steering algortihms due to floating point math behavior on modern computers. In order to solve those numerical stability issues, a third segment type was introduced: the spin-in-place segment. These segments were assumed to have no translational offset and changed the interpretation of the desired speed from a translational speed to a rotational speed.

\subsection{Steering Algorithms}\label{subsec:steering_algorithms}

Two different steering algorithms were developed and evaluated for use in this precision navigation system. The first of these is an algorithm called \emph{second-order steering} (see \autoref{subsubsec:second_order_steering} \todo{fix the reference name to subsubsection}) and the second, developed to address deficiencies in the first, is called \emph{phase space steering}. Both of these algorithms have the same form, as laid out in \autoref{alg:generic_steering_algorithm}.

\begin{algorithm}
\caption{Generic Steering Algorithm}
\label{alg:generic_steering_algorithm}
\DontPrintSemicolon

\KwIn{$\hat{x_t}$, $x_t$}
\KwOut{$v$, $\omega$}

$v$, $\omega$ = executeSteeringAlgorithm($\hat{x_t}$, $x_t$)\;

\end{algorithm}

The inputs to \autoref{alg:generic_steering_algorithm} are the desired robot state ($\hat{x_t}$) and the current robot state ($x_t$) as estimated by the precision localization system. The steering algorithm outputs are the translational velocity ($v$) and rotational velocity ($\omega$) that, when commanded to the robot base, are the best commands to ensure convergence to the desired state. Since these are only individual commands, not a sequence of them, the steering algorithm must be run at a regular rate, recomputing the commands each time, to ensure convergence. In this thesis, the steering algorithms were tuned to run at 20 Hz.

\subsubsection{Second-Order Steering}\label{subsubsec:second_order_steering}



\begin{comment}
This section details the steering algorithms used by this precision navigation stack

Specifically, the following will be discussed:
\begin{enumerate}
\item Second Order steering
\item Phase Space steering
\item Lfollow for both linear paths and spin in places
	Need to mention the interaction with the PID time constants and such
\item Added a spin in place segment descriptor because of instabilities in the tiny arcs
\end{enumerate}

\end{comment}