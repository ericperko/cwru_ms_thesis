\section{Localization}\label{sec:localization}

One of the major components of any navigation system is the localization subsystem. The job of the localization subsystem on any robot is to determine where the robot is. Knowing the robot's pose is essential to being able to actually navigate to a specific goal position, otherwise the robot won't know once it reaches that goal position. The pose estimates generated by the localization subsystem may also be used in control loops or otherwise by the planning and control subsystems. For example, the local planner described in \autoref{subsec:base_local_planner} uses the pose (2D position and heading) as well as the translational and rotational velocities of the base when generating possible trajectories to evaluate. The precision navigation system described in this thesis uses the pose and velocity estimates as control variables to generate commands that follow the desired path (see \autoref{sec:steering}).

For precise navigation, the robot not only needs to know where it is, but that pose estimate must be at least as accurate as the precision navigation system as a whole is designed to be. For example, a robot that must pass through a doorway with less than seven centimeters of clearance on either side must know where it is at any given time to at least seven centimeters or it is unlikely to reliably (and smoothly) get through the doorway. One important consideration is that the localization for precise navigation does not need to be accurate, only precise. As long as the coordinates for a given real world position are estimated to be the same over multiple runs, it is unimportant if those estimates do not match something like a floorplan. The localization subsystem used by the precision navigation system described in this thesis is broken up into two separate components, depending on what type of reference frame their pose estimates are in: the relative localization component and the absolute localization component.

\subsection{Relative Localization}\label{subsec:relative_localization}

The first major component of the localization subsystem used in this thesis is the relative frame localization system. This component generates pose estimates relative to wherever the robot was powered on. The relative localization subsystem also generates estimates of the translation and rotational velocities. While these estimates are important, the relative frame position estimate is only good for uses that can tolerate a reference frame that drifts over long periods of time and is not fixed between times when the robot is powered on and off. For these reasons, it is not useful for describing goal points or global planning. It is useful for local planning and collision avoidance, as both of those are tolerant to drift in the reference frame. The estimates generated by the relative frame localization are also useful for the control algorithms used in this thesis because they can be generated at a high rate thanks to the computational simplicity of the algorithms used compared to absolute frame localization algorithms as described in \autoref{subsec:absolute_localization}.

HARLIE's relative frame localization is generated by using an Extended Kalman Filter (EKF) \autocites{Larsen1999}{Welch95anintroduction}{ProbRobotics}. The EKF is an extension of the standard Kalman Filter algorithm, used for optimal state estimation in linear systems, to non-linear systems such as a differential drive robot. Using a model of the dynamic system and measurements from a variety of sensors, the EKF is able to produce a state estimate that is more accurate than any sensor individually. The EKF on HARLIE uses two of the sensors described in \autoref{subsec:harlie_setup} to produce these relative frame state estimates: the encoders and the gyroscope. \autoref{alg:harlie_ekf_algorithm} is a description of the exact EKF algorithm used on HARLIE. The values of each set of matrices and functions used are detailed afterwards.

\begin{algorithm}
\caption{HARLIE's Extended Kalman Filter}
\label{alg:harlie_ekf_algorithm}
\DontPrintSemicolon
\SetKwFunction{ZeroOutBiasXYThetaCovariance}{ZeroOutBiasXYThetaCov}

\KwIn{$x_{t-1}$, $P_{t-1}$, $z_t$}
\KwOut{$x_t$, $P_t$}

$\hat{x_t} = f(x_{t-1})$\;
$\hat{P_t} = G \cdot P_{t-1} \cdot G^T + Q$\;
$\hat{P_t} = $ \ZeroOutBiasXYThetaCovariance{$\hat{P_t}$}\;
\ForEach{$z^i_t \in z_t$}
{
	$y^i_t = z^i_t - h(\hat{x_t})$\;
	$S = H \cdot \hat{P_t} \cdot H^T + R$\;
	$K = \hat{P_t} \cdot H^T \cdot S^{-1}$\;
	$\hat{x_t} = \hat{x_t} + K \cdot y^i_t$\;
	$\hat{P_t} = \left(I - K \cdot H \right) \cdot \hat{P_t}$\;
}
$x_t = \hat{x_t}$\;
$P_t = \hat{P_t}$\;
\end{algorithm}

The inputs to \autoref{alg:harlie_ekf_algorithm} are the previous state estimate ($x_{t-1}$), the covariance of the previous state estimate ($P_{t-1}$) and a set of new measurements ($z_t$). The filter outputs an estimate of the current state ($x_t$) and the covariance of the current state ($P_t$). In \autoref{alg:harlie_ekf_algorithm}, lines 1-3 are known as the prediction step and depend only on previous state and a model of the system. Lines 4-10 are the measurement updates where the EKF uses sensory information to refine the state estimate. The matrices used in the measurement update step are specific to which sensor generated the $z^i_t$ information being used, since different sensors generate different types of measurements. The following sections detail the prediction and two different sets of measurement updates that HARLIE's EKF uses.

\subsubsection{Prediction Step}\label{subsubsec:harlie_ekf_prediction}

The prediction step is run every filter update, whether there are new measurements or not. This generates state estimates at a predictable, high fixed rate (50 Hz). The filter runs at this high fixed rate so that the navigation control algorithms always have fresh state information for their control loops.

\begin{equation}
	x_{t-1} = 
	\begin{bmatrix}
		x &
		y &
		\theta &
		v &
		\omega &
		b_{\omega}
	\end{bmatrix}^T
	\label{eq:harlie_ekf_state}
\end{equation}

\eqref{eq:harlie_ekf_state} is the state estimate used and generated by the filter. $x$ and $y$ are the Cartesian coordinates of the robot on the ground plane, relative to where the robot was powered on. $\theta$ is the robot's heading relative to its heading when it was powered on. $v$ is the translational velocity of the robot and $\omega$ is the rotational velocity (yaw rate) of the robot. $b_{\omega}$ is a bias term to represent the drift present in the gyroscope's rotational velocity estimates.

\begin{equation}
	P_{t-1} =
	\begin{bmatrix}
		\sigma_x^2 & \sigma_x\sigma_y & \ldots & \sigma_x\sigma_{b_{\omega}} \\
		\sigma_y\sigma_x & \sigma_y^2 & \ldots & \sigma_y\sigma_{b_{\omega}} \\
		\vdots & \vdots & \ddots & \vdots \\
		\sigma_{b_{\omega}}\sigma_x & \sigma_{b_{\omega}}\sigma_y & 
			\ldots & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_state_covariance}
\end{equation}

\eqref{eq:harlie_ekf_state_covariance} is the covariance of the state estimate. It is an $n\times n$ matrix, where $n$ is the number of elements in the state vector and arranged such that element $m,n$ of the covariance matrix is the covariance of the $m$-th element of the state vector with the $n$-th element of the state vector.

\begin{equation}
	f\left(x_{t-1}\right) =
	\begin{bmatrix}
		x + v \cdot dt \cdot \cos\left(\theta\right) \\
		y + v \cdot dt \cdot \sin\left(\theta\right)  \\
		\theta + \omega \cdot dt \\
		v \\
		\omega \\
		b_{\omega}
	\end{bmatrix}
	\label{eq:harlie_ekf_process_model}
\end{equation}

\eqref{eq:harlie_ekf_process_model} is the process model used in line 1 of \autoref{alg:harlie_ekf_algorithm}. This function generates a prediction of the state at time $t$ given an estimate of the state at time $t-1$, where $dt$ is the time between filter updates (50 Hz or 0.02 seconds in this case). This particular process model assumes that the robot maintains constant translational and rotational velocities, as well as a constant bias term; since these terms are not truly constant, the process noise must be large enough to include the changes in these values between filter update cycles. The model for the change in location and heading assumed that any rotations are pivot turns at the end of the motion; as such, it does not model constant curvature arcs. While there are other odometry models that do address constant curvature arcs (such as those in \autocite{ProbRobotics}), the model in \eqref{eq:harlie_ekf_process_model} is sufficiently accurate when run at the 50 Hz rate of the filter and computationally simpler than models that take into account constant curvature arcs. If the filter were slowed down, a more complex odometry model might become necessary to maintain accuracy.

\begin{equation}
	G =
	\begin{bmatrix}
		1 & 0 & -v \cdot dt \cdot \sin\left(\theta\right) & dt \cdot \cos\left(\theta\right) & 0 & 0 \\
		0 & 1 & v \cdot dt \cdot \cos\left(\theta\right) & dt \cdot \sin\left(\theta\right) & 0 & 0 \\
		0 & 0 & 1 & 0 & dt & 0 \\
		0 & 0 & 0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 0 & 0 & 1 
	\end{bmatrix}
	\label{eq:harlie_ekf_process_jacobian}
\end{equation}

\eqref{eq:harlie_ekf_process_jacobian} is the Jacobian of the process model \eqref{eq:harlie_ekf_process_model} with respect to the state vector \eqref{eq:harlie_ekf_state}.

\begin{equation}
	Q =
	\begin{bmatrix}
		\sigma_{x}^2 & 0 & 0 & 0 & 0 & 0 \\
		0 & \sigma_{y}^2 & 0 & 0 & 0 & 0 \\
		0 & 0 & \sigma_{\theta}^2 & 0 & 0 & 0 \\
		0 & 0 & 0 & \sigma_{v}^2 & 0 & 0 \\
		0 & 0 & 0 & 0 & \sigma_{\omega}^2 & 0 \\
		0 & 0 & 0 & 0 & 0 & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_process_noise}
\end{equation}

\eqref{eq:harlie_ekf_process_noise} is the noise in the process model. It represents the uncertainty of the model and must account for any unmodeled characteristics of the system (such as that the velocity is not constant). For HARLIE, $\sigma_{x} = 0.001$, $\sigma_{y} = 0.001$, $\sigma_{\theta} = 0.001$, $\sigma_{v} = \sqrt{10}$, $\sigma_{\omega} = \sqrt{10}$ and $\sigma_{b_{\omega}} = 1.0\times 10^{-5}$.

\begin{equation}
	\mathsf{\ZeroOutBiasXYThetaCovariance}\left(P_t\right) = 
	\begin{bmatrix}
		\sigma_x^2 & \ldots & \ldots & \ldots & \sigma_x\sigma_\omega & 0 \\
		\vdots & \ddots & \ldots & \ldots & \sigma_y\sigma_\omega & 0 \\
		\vdots & \vdots & \ddots & \ldots & \sigma_\theta\sigma_\omega & 0 \\
		\vdots & \vdots & \vdots & \ddots & \ldots & \sigma_v\sigma_{b_{\omega}} \\
		\sigma_\omega\sigma_x & \sigma_\omega\sigma_y & \sigma_\omega\sigma_\theta & \vdots & \ddots & \sigma_\omega\sigma_{b_{\omega}} \\
		0 & 0 & 0 & \sigma_{b_{\omega}}\sigma_v & \sigma_{b_{\omega}}\sigma_\omega & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_zero_bias_cov}
\end{equation}

\eqref{eq:harlie_ekf_zero_bias_cov} is the function applied to the prediction covariance in line 3 of \autoref{alg:harlie_ekf_algorithm}. This function zeros out the covariance between the yaw rate bias $b_{\omega}$ and $x$, $y$ and $\theta$. This is necessary to prevent the $x$, $y$ or $\theta$ terms of the prediction from adjusting the bias -- which is a reasonable assumption, as the bias term cannot physically be influenced by $x$, $y$ or $\theta$. Without applying this function, bias estimation would become unstable quickly due to the influence of those variables.

\subsubsection{Encoder Measurement Update}\label{subsubsec:harlie_ekf_encoder_measurement}

The encoder measurement update runs whenever there are new encoder readings. On HARLIE, the encoders are sampled once every filter update, so there is always a new encoder reading after completing the prediction step.

\begin{equation}
	z_t^i = 
	\begin{bmatrix}
		d_{left} \\
		d_{right}
	\end{bmatrix}
	\label{eq:harlie_ekf_encoder_z}
\end{equation}

\eqref{eq:harlie_ekf_encoder_z} is the form of the measurement returned by measuring the encoders. $d_{left}$ and $d_{right}$ are the change in the left and right wheel encoders, respectively.

\begin{equation}
	h\left(\hat{x_t}\right) =
	\begin{bmatrix}
		\frac{1}{2} \cdot dt \cdot \left( 2 \cdot v + b \cdot \omega \right) \\
		\frac{1}{2} \cdot dt \cdot \left( 2 \cdot v - b \cdot \omega \right) 
	\end{bmatrix}
	\label{eq:harlie_ekf_encoder_h}
\end{equation}

\eqref{eq:harlie_ekf_encoder_h} is the function used in line 5 of \autoref{alg:harlie_ekf_algorithm} that generates a prediction of the measurement, given the estimated state $\hat{x_t}$. \eqref{eq:harlie_ekf_encoder_h} is only used when $z_t^i$ comes from the encoders. $dt$ is again 0.02 seconds (50 Hz), since the encoders are sampled every filter update. $b$ is the track width of the base. 

\begin{equation}
	v = \frac{d_{right}+d_{left}}{2}
	\label{eq:harlie_ekf_odometry_model_v}
\end{equation}

\begin{equation}
	\omega = \frac{d_{right} - d_{left}}{b}
	\label{eq:harlie_ekf_odometry_model_w}
\end{equation}

\eqref{eq:harlie_ekf_odometry_model_v} and \eqref{eq:harlie_ekf_odometry_model_w} are the odometry equations that \eqref{eq:harlie_ekf_encoder_h} is based on. Using these two equations, the translational and rotational velocities can be related to the change in the individual encoders. $b$, the track width, is the distance along the axle between the two wheels.

\begin{equation}
	H =
	\begin{bmatrix}
		0 & 0 & 0 & dt & \frac{1}{2} \cdot b \cdot dt & 0 \\
		0 & 0 & 0 & dt & -\frac{1}{2} \cdot b \cdot dt & 0 \\
	\end{bmatrix}
	\label{eq:harlie_ekf_encoder_jacobian}
\end{equation}

\eqref{eq:harlie_ekf_encoder_jacobian} is the Jacobian of \eqref{eq:harlie_ekf_encoder_h} with respect to \eqref{eq:harlie_ekf_state}.

\begin{equation}
	R =
	\begin{bmatrix}
		d_{left}^2 \cdot \alpha_{left} + \epsilon & 0 \\
		0 & d_{right}^2 \cdot \alpha_{right} + \epsilon
	\end{bmatrix}
	\label{eq:harlie_ekf_encoder_measurement_noise}
\end{equation}

\eqref{eq:harlie_ekf_encoder_measurement_noise} is the noise in the encoder measurement. The noise model used has two components, one constant and one variable. $\epsilon$ is a small constant value to represent an error of $\pm 1$ encoder tick, so that even when there was no change in the encoders, the measurement noise accounts for possible mismeasurement. $\alpha_{right}$ and $\alpha_{left}$ are parameters used to control the amount of variable noise applied to the measurement. This models the fact that the encoders become more unreliable when the robot is moving more quickly (or the wheels are slipping). For HARLIE, $\epsilon = 1.0\times10^{-8}$, $\alpha_{right} = 0.0002$ and $\alpha_{left} = 0.0002$.

\subsubsection{Gyroscope Measurement Update}\label{subsubsec:harlie_ekf_gyro_measurement}

The gyroscope measurement update runs whenever there is a new gyroscope reading. On HARLIE, the gyroscope is sampled once every filter update, so there is always a new reading after completing the prediction step.

\begin{equation}
	z_t^i = 
	\begin{bmatrix}
		\omega_{sample}
	\end{bmatrix}
	\label{eq:harlie_ekf_gyro_z}
\end{equation}

\eqref{eq:harlie_ekf_gyro_z} is the form of the measurement returned by the gyroscope sampling component.

\begin{equation}
	h\left(\hat{x_t}\right) =
	\begin{bmatrix}
		\omega + b_{\omega}
	\end{bmatrix}
	\label{eq:harlie_ekf_gyro_h}
\end{equation}

\eqref{eq:harlie_ekf_gyro_h} is the function used in line 5 of \autoref{alg:harlie_ekf_algorithm} that generates a prediction of the gyroscope measurement, given the estimated state $\hat{x_t}$. \eqref{eq:harlie_ekf_gyro_h} is only used when $z_t^i$ comes from the gyroscope.

\begin{equation}
	H =
	\begin{bmatrix}
		0 & 0 & 0 & 0 & 1 & 1
	\end{bmatrix}
	\label{eq:harlie_ekf_gyro_jacobian}
\end{equation}

\eqref{eq:harlie_ekf_gyro_jacobian} is the Jacobian of \eqref{eq:harlie_ekf_gyro_h} with respect to \eqref{eq:harlie_ekf_state}.

\begin{equation}
	R =
	\begin{bmatrix}
		\omega_{sample}^2 \cdot \alpha_{gyro} + \gamma
	\end{bmatrix}
	\label{eq:harlie_ekf_gyro_measurement_noise}
\end{equation}

\eqref{eq:harlie_ekf_gyro_measurement_noise} is the noise in the gyroscope measurement. Analogously to the encoder noise, this noise model also has a variable $\left(\alpha_{gyro}\right)$ and constant $\left(\gamma\right)$ component. For HARLIE, $\alpha_{gyro} = 0.000048345$ and $\gamma = 0.00000019$.

\subsection{Absolute Localization}\label{subsec:absolute_localization}

The second major component of the localization subsystem used in this thesis is the absolute frame localization system. This component generates pose estimates relative to some fixed reference pose, such as the origin of a map or, for outdoor robots, GPS coordinates. As this thesis focused on indoor robots, the absolute localization system generates pose estimates relative to the origin of the map where the robot is currently operating. Unlike the relative localization system described in \autoref{subsec:relative_localization}, the origin of the map (and therefore the pose estimates) does not drift over time or whenever the robot is powered on and off. Because the absolute reference frame does not drift, it is suitable for describing things like goal points or long-term paths. While the absolute reference frame position estimates do not drift, they are not suitable for things that need position updates at high rates due to the computational complexity of the algorithms involved.

HARLIE's absolute frame localization is generated by an algorithm called Adaptive Monte Carlo Localization (AMCL) \autocites{Dellaert_1999_533}{Fox01122003}{ProbRobotics}. AMCL is a type of probabilistic localization algorithm, based on a particle filter, that adaptively varies the number of particles used to represent the posterior. Each particle represents an estimate of the robot's pose relative to the fixed origin of the \emph{a priori} map. These estimates are updated each cycle based on the pose and velocity estimates from the relative localizations algorithm described in \autoref{subsec:relative_localization}, the laser data from the SICK LMS291 and the \emph{a priori} map. The output of AMCL is a set of possible poses (each particle) with an associated weight; since weights are proportional to the likelihood of each pose being the true pose, the best estimate of the robot's current absolute position is simply the particle with the highest likelihood. The \emph{a priori} map required by AMCL can be generated in a number of ways, such as the output of a SLAM algorithm like GMapping \autocite{Grisetti07improvedtechniques} or the building's blueprints \autocite{Fish2012}. This thesis relied on a map generated by the ROS GMapping package with a five centimeter resolution for use while generating precision localization estimates.

The AMCL algorithm used on HARLIE was provided by the ROS ``amcl" package \autocite{AMCLWiki}. The amcl package has a large number of parameters that control its behavior. As configured, it used the algorithms \emph{KLD\_Sampling\_MCL}, \emph{sample\_motion\_model\_odom\-etry} and \emph{like\-lihood\_field\_range\_finder\_model} as described in \autocite{ProbRobotics}. \emph{KLD\_Sampling\_MCL} implements the adaptive particle filter localization described previously. \emph{sample\_mo\-tion\_model\_odom\-etry} draws samples from the distribution given by sampling based on the change in pose and adding those samples to the last computed pose. \emph{like\-lihood\_field\_range\_finder\_model} precomputes the likelihood of a laser ``hit'' for each cell in the map - at runtime, getting the probability of a given laser range reading is as simple as looking up the 2D coordinates of the hit location in the precomputed likelihood field, which makes it much faster than alternative methods based on raytracing each beam through the entire map. This likelihood field model can be slightly less accurate though, for example if the beam should have intersected with a known obstacle prior to the hit on another known obstacle, the likelihood field model will only return the probability of the hit on the second known obstacle, not the first. However, in our indoor environment, these situations are not very likely to occur and so the speed advantages of the likelihood field model outweigh the accuracy advantages of the raytracing based model.

As mentioned previously, the ROS amcl package has a large number of parameters available. All but six of these parameters were left at their default values. Four odometry motion model related parameters were changed: $odom\_alpha1 = 1.2$, $odom\_alpha2 = 1.2$, $odom\_alpha3 = 1.8$, $odom\_alpha4 = 1.2$. These increased the expected noise levels in the odometry estimates from the relative localization algorithm from their default values of $0.2$ to values that were more accurate for the actual noise in those estimates. Essentially, this allowed the AMCL algorithm to rely more on the laser than on the odometry estimates; because HARLIE operated indoors with a high quality laser and high resolution \emph{a priori} map, this led to more precise absolute pose estimates than the default parameters. Two parameters that control how often AMCL recomputes the absolute pose estimate were also modified: $update\_min\_d = 0.05$ from $0.2$ meters and $update\_min\_a = 0.1$ from $\pi/6 $ radians. Modifying these parameters caused AMCL to recompute the position estimate every five centimeters or $0.1$ radians; recomputing the pose more often while moving (the decrease in $update\_min\_d$) led to smoother absolute pose estimates which prevented any large jumps in absolute position in between trajectory generation loops.

\begin{comment}
This section details the PSO used on HARLIE and has data and figures and shit for how accurate it is

Outline:
	Why do we need localization? Why do we need PRECISE localization?

	Parts
		Relative Localization
			EKF on HARLIE
		Absolute Localization
			AMCL algorithm
			Needs tuned to prevent pops
		Results

\end{comment}
