\section{Localization}\label{sec:localization}

One of the major components of any navigation system is the localization subsystem. The job of the localization subsystem on any robot is to determine where the robot is. Knowing where the robot is essential to being able to actually navigate to a specific goal position, otherwise the robot won't know once it reaches that goal position. The pose estimates generated by the localization subsystem may also be used in control loops or otherwise by the planning and control subsystems. For example, the local planner described in \autoref{subsec:base_local_planner} uses the pose (2D position and heading) as well as the translational and rotational velocities of the base when generating possible trajectories to evaluate. The precision navigation system described in this thesis uses the pose and velocity estimates as control variables to generate commands that follow the desired path \todo{reference wherever I eventually describe the steering algorithms}.

For precise navigation, the robot not only needs to know where it is, but that pose esimate must be at least as accurate as the precision navigation system as a whole is designed to be. The localization subsystem used by the precision navigation system described in this thesis is broken up into two separate components, depending on what type of reference frame their pose estimates are in: the relative localization component and the absolute localization component.

\subsection{Relative Localization}\label{subsec:relative_localization}

The first major component of the localization subsystem used in this thesis is the relative frame localization system. This component generates pose estimates relative to wherever the robot was powered on. The relative localization subsystem also generates estimates of the translation and rotational velocities. While these estimates are important, the relative frame position estimate is only good for uses that can tolerate a reference frame that drifts over long periods of time and is not fixed between times when the robot is powered on and off. For these reasons, it is not useful for describing goal points or global planning. It is useful for local planning and collision avoidance, as both of those are tolerant to drift in the reference frame. The estimates generated by the relative frame localization are also useful for the control algorithms used in this thesis because they can be generated at a high rate thanks to the computional simplicity of the algorithms used compared to absolute frame localization algorithms as described in \autoref{subsec:absolute_localization}.

HARLIE's relative frame localization is generated by using an Extended Kalman Filter (EKF) \autocites{Larsen1999}{Welch95anintroduction}{ProbRobotics}. The EKF is an extension of the standard Kalman Filter algorithm, used for optimal state estimation in linear systems, to non-linear systems such as a differential drive robot. Using a model of the dynamic system and measurements from a variety of sensors, the EKF is able to produce a state estimate that is more accurate than any sensor individually. The EKF on HARLIE uses two of the sensors described in \autoref{subsec:harlie_setup} to produce these relative frame state estimates: the encoders and the gyroscope. \autoref{alg:harlie_ekf_algorithm} is a description of the exact EKF algorithm used on HARLIE. The values of each set of matrices and functions used are detailed afterwards.

\begin{algorithm}
\caption{HARLIE's Extended Kalman Filter}
\label{alg:harlie_ekf_algorithm}
\DontPrintSemicolon
\SetKwFunction{ZeroOutBiasXYThetaCovariance}{ZeroOutBiasXYThetaCovariance}

\KwIn{$x_{t-1}$, $P_{t-1}$, $z_t$}
\KwOut{$x_t$, $P_t$}

$\hat{x_t} = f(x_{t-1})$\;
$\hat{P_t} = G \cdot P_{t-1} \cdot G^T + Q$\;
$\hat{P_t} = $ \ZeroOutBiasXYThetaCovariance{$\hat{P_t}$}\;
\ForEach{$z^i_t \in z_t$}
{
	$y^i_t = z^i_t - h(\hat{x_t})$\;
	$S = H \cdot \hat{P_t} \cdot H^T + R$\;
	$K = \hat{P_t} \cdot H^T \cdot S^{-1}$\;
	$\hat{x_t} = \hat{x_t} + K \cdot y^i_t$\;
	$\hat{P_t} = \left(I - K \cdot H \right) \cdot \hat{P_t}$\;
}
$x_t = \hat{x_t}$\;
$P_t = \hat{P_t}$\;
\end{algorithm}

The inputs to \autoref{alg:harlie_ekf_algorithm} are the previous state estimate ($x_{t-1}$), the covariance of the previous state estimate ($P_{t-1}$) and a set of new measurements ($z_t$). The filter outputs an estimate of the current state ($x_t$) and the covariance of the current state ($P_t$). In \autoref{alg:harlie_ekf_algorithm}, lines 1-3 are known as the prediction step and depends only on previous state and a model of the system. Lines 4-10 are the measurement updates where the EKF uses sensory information to refine the state estimate. The matrices used in the measurement update step are specific to which sensor generated the $z^i_t$ information being used, since different sensors generate different types of measurements. The following sections detail the prediction and two different sets of measurement updates that HARLIE's EKF uses.

\subsubsection{Prediction Step}\label{subsubsec:harlie_ekf_prediction}

The prediction step is run every filter update, whether there are new measurements or not. This generates state estimates at a predictable, high fixed rate (50 Hz). The filter runs at this high fixed rate so that the navigation control algorithms always have fresh state information for their control loops.

\begin{equation}
	x_{t-1} = 
	\begin{bmatrix}
		x &
		y &
		\theta &
		v &
		\omega &
		b_{\omega}
	\end{bmatrix}^T
	\label{eq:harlie_ekf_state}
\end{equation}

\eqref{eq:harlie_ekf_state} is the state estimate used and generated by the filter. $x$ and $y$ are the cartesian coordinates of the robot on the ground plane, relative to where the robot was powered on. $\theta$ is the robot's heading relative to its heading when it was powered on. $v$ is the translational velocity of the robot and $\omega$ is the rotational velocity (yaw rate) of the robot. $b_{\omega}$ is a bias term to represent the drift present in the gyroscope's rotational velocity estimates.

\begin{equation}
	P_{t-1} =
	\begin{bmatrix}
		\sigma_x^2 & \sigma_x\sigma_y & \ldots & \sigma_x\sigma_{b_{\omega}} \\
		\sigma_y\sigma_x & \sigma_y^2 & \ldots & \sigma_y\sigma_{b_{\omega}} \\
		\vdots & \vdots & \ddots & \vdots \\
		\sigma_{b_{\omega}}\sigma_x & \sigma_{b_{\omega}}\sigma_y & 
			\ldots & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_state_covariance}
\end{equation}

\eqref{eq:harlie_ekf_state_covariance} is the covariance of the state estimate. It is an $n\times n$ matrix, where $n$ is the number of elements in the state vector and arranged such that element $m,n$ of the covariance matrix is the covariance of the $m$-th element of the state vector with the $n$-th element of the state vector.

\begin{equation}
	f\left(x_{t-1}\right) =
	\begin{bmatrix}
		x + v \cdot dt \cdot \cos\left(\theta\right) \\
		y + v \cdot dt \cdot \sin\left(\theta\right)  \\
		\theta + \omega \cdot dt \\
		v \\
		\omega \\
		b_{\omega}
	\end{bmatrix}
	\label{eq:harlie_ekf_process_model}
\end{equation}

\eqref{eq:harlie_ekf_process_model} is the process model used in line 1 of \autoref{alg:harlie_ekf_algorithm}. This function generates a prediction of the state at time $t$ given an estimate of the state at time $t-1$, where $dt$ is the time between filter updates (50 Hz or 0.02 seconds in this case). The particular process model used assumes that the robot maintains constant translational and rotational velocities, as well as a constant bias term; since these terms are not truly constant, the process noise must be large enough to include the changes in these values between filter update cycles. The model for the change in location and heading assumed that any rotations are pivot turns at the end of the motion; as such, it doesn't model constant curvature arcs. While there are other odometry models that do address constant curvature arcs (such as those in \autocite{ProbRobotics}), the model in \eqref{eq:harlie_ekf_process_model} is sufficiently accurate when run at the 50 Hz rate of the filter and computationally simpler than models that take into account constant curvature arcs. If the filter were slowed down, a more complex odometry model might become necessary to maintain accuracy. \todo{future work: try more complex odometry models and see if they increase accuracy}

\begin{equation}
	G =
	\begin{bmatrix}
		1 & 0 & -v \cdot dt \cdot \sin\left(\theta\right) & dt \cdot \cos\left(\theta\right) & 0 & 0 \\
		0 & 1 & v \cdot dt \cdot \cos\left(\theta\right) & dt \cdot \sin\left(\theta\right) & 0 & 0 \\
		0 & 0 & 1 & 0 & dt & 0 \\
		0 & 0 & 0 & 1 & 0 & 0 \\
		0 & 0 & 0 & 0 & 1 & 0 \\
		0 & 0 & 0 & 0 & 0 & 1 
	\end{bmatrix}
	\label{eq:harlie_ekf_process_jacobian}
\end{equation}

\eqref{eq:harlie_ekf_process_jacobian} is the Jacobian of the process model \eqref{eq:harlie_ekf_process_model} with respect to the state vector \eqref{eq:harlie_ekf_state}.

\begin{equation}
	Q =
	\begin{bmatrix}
		\sigma_{x}^2 & 0 & 0 & 0 & 0 & 0 \\
		0 & \sigma_{y}^2 & 0 & 0 & 0 & 0 \\
		0 & 0 & \sigma_{\theta}^2 & 0 & 0 & 0 \\
		0 & 0 & 0 & \sigma_{v}^2 & 0 & 0 \\
		0 & 0 & 0 & 0 & \sigma_{\omega}^2 & 0 \\
		0 & 0 & 0 & 0 & 0 & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_process_noise}
\end{equation}

\eqref{eq:harlie_ekf_process_noise} is the noise in the process model. It represents the uncertainty of the model and must account for any unmodeled characteristics of the system (such as that the velocity is not constant). For HARLIE, $\sigma_{x} = 0.001$, $\sigma_{y} == 0.001$, $\sigma_{\theta} = 0.001$, $\sigma_{v} = \sqrt{10}$, $\sigma_{\omega} = \sqrt{10}$ and $\sigma_{b_{\omega}} = 1.0\times 10^{-5}$.

\begin{equation}
	ZeroOutBiasXYThetaCovariance\left(P_t\right) = 
	\begin{bmatrix}
		\sigma_x^2 & \ldots & \ldots & \ldots & \sigma_x\sigma_\omega & 0 \\
		\vdots & \ddots & \ldots & \ldots & \sigma_y\sigma_\omega & 0 \\
		\vdots & \vdots & \ddots & \ldots & \sigma_\theta\sigma_\omega & 0 \\
		\vdots & \vdots & \vdots & \ddots & \ldots & \sigma_v\sigma_{b_{\omega}} \\
		\sigma_\omega\sigma_x & \sigma_\omega\sigma_y & \sigma_\omega\sigma_\theta & \vdots & \ddots & \sigma_\omega\sigma_{b_{\omega}} \\
		0 & 0 & 0 & \sigma_{b_{\omega}}\sigma_v & \sigma_{b_{\omega}}\sigma_\omega & \sigma_{b_{\omega}}^2
	\end{bmatrix}
	\label{eq:harlie_ekf_zero_bias_cov}
\end{equation}

\subsection{Absolute Localization}\label{subsec:absolute_localization}

\begin{comment}
This section details the PSO used on HARLIE and has data and figures and shit for how accurate it is

Outline:
	Why do we need localization? Why do we need PRECISE localization?

	Parts
		Relative Localization
			EKF on HARLIE
		Absolute Localization
			AMCL algorithm
			Needs tuned to prevent pops
	Results

\end{comment}
